[[task-dev-guide]]
= Task Developer Guide

This section covers how to create, test, and run Spring Cloud Task applications on your local machine.
It also shows how to map these applications into Spring Cloud Data Flow and deploy them.

[[task-dev-guide-prebuilt-apps]]
== Prebuilt Applications

The link:http://cloud.spring.io/spring-cloud-task-app-starters/[Spring Cloud Task App Starters] project provides many applications that you can start using right away.
For example, there is a timestamp application that prints the timestamp to the console.
All the applications are based on link:https://projects.spring.io/spring-boot/[Spring Boot] and link:https://cloud.spring.io/spring-cloud-task/[Spring Cloud Task].

Applications are published as Maven artifacts as well as Docker images.
For GA releases, the Maven artifacts are published to Maven central and the link:http://repo.spring.io/release[Spring Release Repository].
Milestone and snapshot releases are published to the link:http://repo.spring.io/milestone[Spring Milestone] and link:http://repo.spring.io/snapshot[Spring Snapshot] repositories, respectively.
Docker images are pushed to link:https://hub.docker.com/u/springcloudtask/[Docker Hub]

The root location of the Spring Repository that hosts the GA artifacts of prebuilt applications is http://repo.spring.io/release/org/springframework/cloud/task/app/

[[task-dev-guide-running-prebuilt-apps]]
== Running Prebuilt Applications

You can run the timestamp application by using `java -jar`.

To get started, download the sample application, as follows:

[source,bash]
wget https://repo.spring.io/libs-release/org/springframework/cloud/task/app/timestamp-task/1.3.0.RELEASE/timestamp-task-1.3.0.RELEASE.jar

That file contains a Spring Boot applications that includes the link:{spring-boot-docs-reference}/html/production-ready.html[Spring Boot Actuator] and the link:{spring-boot-docs-reference}/html/boot-features-security.html[Spring Security Starter].
You can specify link:{spring-boot-docs-reference}/html/common-application-properties.html[common Spring Boot properties] to configure each application.

Now you can run the timestamp application, as follows:

[source,bash]
java -jar timestamp-task-1.3.0.RELEASE.jar --logging.level.org.springframework.cloud.task=DEBUG

NOTE: The `--logging.level.org.springframework.cloud.task=DEBUG` option lets you see output that would not otherwise be written to the console. Because Spring Cloud Task uses an in-memory database to store its results (and that in-memory database is destroyed at the end of the run), the `DEBUG` option is the only way to see the output from the timestamp task.

The timestamp application shows the following output (in the midst of much other output):

[source,bash]
----
2018-03-12 13:45:14.583  INFO 4810 --- [           main] TimestampTaskConfiguration$TimestampTask : 2018-03-12 13:45:14.583
2018-03-12 13:45:14.609 DEBUG 4810 --- [           main] o.s.c.t.r.support.SimpleTaskRepository   : Updating: TaskExecution with executionId=1 with the following {exitCode=0, endTime=Mon Mar 12 13:45:14 CDT 2018, exitMessage='null', errorMessage='null'}
----

The first line shows the timestamp generated by the Timestamp task. The second line shows an exit code of 0 and no error. Had an error occurred, the exit code would be something other than 0, and the `errorMessage` would show the exception that was thrown.

If you have debug mode turned on, you can get even more information, in a line similar to the following (which appears just prior to the timestamp if you have debug mode turned on):

`2018-03-14 13:47:16.659 DEBUG 78382 --- [ main] o.s.c.t.r.support.SimpleTaskRepository : Creating: TaskExecution{executionId=0, parentExecutionId=null, exitCode=null, taskName='application', startTime=Wed Mar 14 13:47:16 EDT 2018, endTime=null, exitMessage='null', externalExecutionId='null', errorMessage='null', arguments=[]}`

[[task-dev-guide-building-timestamp-task]]
== Building a Timestamp Task

To build your own timestamp task, follow each of these procedures:

. <<task-dev-guide-building-timestamp-task-from-initializer>>
. <<task-dev-guide-building-timestamp-task-recording-error>>
. <<task-dev-guide-building-timestamp-task-adding-pre-post-processing>>
. <<task-dev-guide-building-timestamp-task-bonus-adding-mysql>>
. <<task-dev-guide-building-timestamp-adding-tasks-to-dataflow>>

[[task-dev-guide-building-timestamp-task-from-initializer]]
== Developing Your Timestamp Application

So now that we've used a pre-built timestamp task application, let's create one of our own.
Most IDEs have good support for Apache Maven, so we use it as the build tool for this project.

Before we begin, open a terminal to check that you have valid versions of Java and Maven
installed, as shown in the following two listings:

[source]
$ java -version
java version "1.8.0_31"
Java(TM) SE Runtime Environment (build 1.8.0_31-b13)
Java HotSpot(TM) 64-Bit Server VM (build 25.31-b07, mixed mode)

[source]
$ mvn -v
Apache Maven 3.2.3 (33f8c3e1027c3ddde99d3cdebad2656a31e8fdf4; 2014-08-11T15:58:10-05:00)
Maven home: /usr/local/Cellar/maven/3.2.3/libexec
Java version: 1.8.0_31, vendor: Oracle Corporation

[[task-dev-guide-creating-project]]
=== Creating the Spring Task Project using Spring Initializer
Now let's create and test an application that prints a timestamp to the console.

To do so:

. Visit the link:https://start.spring.io/[Spring Initialzr] site.
.. Create a new Maven project with a *Group* name of `io.spring.demo` and an *Artifact* name of `timestamp`.
.. In the Dependencies text box, type `task` to select the `Cloud Task` dependency.
.. In the Dependencies text box, type `jdbc` then select the `JDBC` dependency.
.. In the Dependencies text box, type `h2` then select the `H2`. (or your favorite database)
.. Click the *Generate Project* button
. Unzip the timestamp.zip file and import the project into your favorite IDE.


[[getting-started-writing-the-code]]
=== Writing the Code

To finish our application, we need to replace the generated `TimestampApplication` code with the following contents so that it will launch a Task.
[source,java]
----
package io.spring.demo.timestamp;

import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.Date;

import org.springframework.boot.CommandLineRunner;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.cloud.task.configuration.EnableTask;
import org.springframework.context.annotation.Bean;

@SpringBootApplication
@EnableTask
public class TimestampApplication {

	@Bean
	public CommandLineRunner commandLineRunner() {
		return new TimestampCommandLineRunner();
	}

	public static void main(String[] args) {
		SpringApplication.run(TimestampApplication.class, args);
	}

	public static class TimestampCommandLineRunner implements CommandLineRunner {

		@Override
		public void run(String... strings) throws Exception {
			DateFormat dateFormat = new SimpleDateFormat("YYYY-MM-dd");
			System.out.println(dateFormat.format(new Date()));
		}
	}
}
----

While it may seem small, quite a bit is going on. For more about Spring
Boot specifics, see the
http://docs.spring.io/spring-boot/docs/current/reference/html/[Spring Boot reference documentation].

Now let's open the `application.properties` file in `src/main/resources`. We need
to configure two properties in `application.properties`: We need to set the application
name (which is translated to the task name), and we need to set the logging for Spring
Cloud Task to `DEBUG` so that we can see what's going on. The following example shows how
to do both:

[source]
----
logging.level.org.springframework.cloud.task=DEBUG
spring.application.name=timestamp
----

[[getting-started-at-task]]
==== The @EnableTask annotation

The first non-boot annotation in our example is the `@EnableTask` annotation. This
class-level annotation tells Spring Cloud Task to bootstrap it's functionality. By
default, it imports an additional configuration class (`SimpleTaskConfiguration`). This
additional configuration registers the `TaskRepository` and the infrastructure for its
use.

In our demo, the `TaskRepository` uses an embedded H2 database to record the results
of a task. This H2 embedded database is not a practical solution for a production environment, since
the H2 DB goes away once the task ends. However, for a quick getting-started
experience, we will use this in our example as well as echoing to the logs what is being updated
in that repository. In the <<features-configuration>> section (later in this
documentation), we cover how to customize the configuration of the pieces provided by
Spring Cloud Task.

When our sample application runs, Spring Boot launches our `TimestampCommandLineRunner`
and outputs our timestamp message to standard out. The `TaskLifecycleListener`
records the start of the task and the end of the task in the repository.

[[getting-started-main-method]]
==== The main method

The main method serves as the entry point to any java application.  Our main method
delegates to Spring Boot's `SpringApplication` class.  You can read more about it in the
Spring Boot documentation.

[[getting-started-clr]]
==== The CommandLineRunner

Spring includes many ways to bootstrap an application's logic. Spring Boot provides
a convenient method of doing so in an organized manner through its `*Runner` interfaces
(`CommandLineRunner` or `ApplicationRunner`). A well behaved task can bootstrap any
logic by using one of these two runners.

The lifecycle of a task is considered from before the `*Runner#run` methods are executed
to once they are all complete. Spring Boot lets an application use multiple
`*Runner` implementations, as does Spring Cloud Task.

NOTE: Any processing bootstrapped from mechanisms other than a `CommandLineRunner` or
`ApplicationRunner` (by using `InitializingBean#afterPropertiesSet` for example) is not
 recorded by Spring Cloud Task.

[[getting-started-running-the-example]]
=== Running the Example

At this point, our application should work.  Since this application is Spring Boot-based,
we can run it from the command line by using `$ mvn spring-boot:run` from the root
of our application, as shown (with its output) in the following example:

[source]
----
$ mvn clean spring-boot:run
....... . . .
....... . . . (Maven log output here)
....... . . .

  .   ____          _            __ _ _
 /\\ / ___'_ __ _ _(_)_ __  __ _ \ \ \ \
( ( )\___ | '_ | '_| | '_ \/ _` | \ \ \ \
 \\/  ___)| |_)| | | | | || (_| |  ) ) ) )
  '  |____| .__|_| |_|_| |_\__, | / / / /
 =========|_|==============|___/=/_/_/_/
 :: Spring Boot ::        (v2.0.3.RELEASE)

2018-07-25 11:11:16.695  INFO 5342 --- [           main] i.s.demo.timestamp.TimestampApplication  : Starting TimestampApplication on Glenns-MacBook-Pro-2.local with PID 5342 (/Users/glennrenfro/project/crap/timestamp/target/classes started by glennrenfro in /Users/glennrenfro/project/crap/timestamp)
2018-07-25 11:11:16.698  INFO 5342 --- [           main] i.s.demo.timestamp.TimestampApplication  : No active profile set, falling back to default profiles: default
2018-07-25 11:11:16.737  INFO 5342 --- [           main] s.c.a.AnnotationConfigApplicationContext : Refreshing org.springframework.context.annotation.AnnotationConfigApplicationContext@1ac857be: startup date [Wed Jul 25 11:11:16 EDT 2018]; root of context hierarchy
2018-07-25 11:11:17.373  INFO 5342 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Starting...
2018-07-25 11:11:17.500  INFO 5342 --- [           main] com.zaxxer.hikari.HikariDataSource       : HikariPool-1 - Start completed.
2018-07-25 11:11:17.507 DEBUG 5342 --- [           main] o.s.c.t.c.SimpleTaskConfiguration        : Using org.springframework.cloud.task.configuration.DefaultTaskConfigurer TaskConfigurer
2018-07-25 11:11:17.508 DEBUG 5342 --- [           main] o.s.c.t.c.DefaultTaskConfigurer          : No EntityManager was found, using DataSourceTransactionManager
2018-07-25 11:11:17.595 DEBUG 5342 --- [           main] o.s.c.t.r.s.TaskRepositoryInitializer    : Initializing task schema for h2 database
2018-07-25 11:11:17.597  INFO 5342 --- [           main] o.s.jdbc.datasource.init.ScriptUtils     : Executing SQL script from class path resource [org/springframework/cloud/task/schema-h2.sql]
2018-07-25 11:11:17.623  INFO 5342 --- [           main] o.s.jdbc.datasource.init.ScriptUtils     : Executed SQL script from class path resource [org/springframework/cloud/task/schema-h2.sql] in 26 ms.
2018-07-25 11:11:17.777  INFO 5342 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Registering beans for JMX exposure on startup
2018-07-25 11:11:17.778  INFO 5342 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Bean with name 'dataSource' has been autodetected for JMX exposure
2018-07-25 11:11:17.781  INFO 5342 --- [           main] o.s.j.e.a.AnnotationMBeanExporter        : Located MBean 'dataSource': registering with JMX server as MBean [com.zaxxer.hikari:name=dataSource,type=HikariDataSource]
2018-07-25 11:11:17.786  INFO 5342 --- [           main] o.s.c.support.DefaultLifecycleProcessor  : Starting beans in phase 0
2018-07-25 11:11:17.805 DEBUG 5342 --- [           main] o.s.c.t.r.support.SimpleTaskRepository   : Creating: TaskExecution{executionId=0, parentExecutionId=null, exitCode=null, taskName='timestamp', startTime=Wed Jul 25 11:11:17 EDT 2018, endTime=null, exitMessage='null', externalExecutionId='null', errorMessage='null', arguments=[]}
2018-07-25 11:11:17.814  INFO 5342 --- [           main] i.s.demo.timestamp.TimestampApplication  : Started TimestampApplication in 1.605 seconds (JVM running for 5.4)
2018-07-25
2018-07-25 11:11:17.827 DEBUG 5342 --- [           main] o.s.c.t.r.support.SimpleTaskRepository   : Updating: TaskExecution with executionId=1 with the following {exitCode=0, endTime=Wed Jul 25 11:11:17 EDT 2018, exitMessage='null', errorMessage='null'}
----

The preceding output has three lines that of interest to us here:

* `SimpleTaskRepository` logged the creation of the entry in the `TaskRepository`.
* The execution of our `CommandLineRunner`, demonstrated by the timestamp output.
* `SimpleTaskRepository` logs the completion of the task in the `TaskRepository`.

NOTE: A simple task application can be found in the samples module of the Spring Cloud
Task Project
https://github.com/spring-cloud/spring-cloud-task/tree/master/spring-cloud-task-samples/timestamp[here].

[[task-dev-guide-building-timestamp-task-recording-error]]
=== Recording an Error

Now that we have a working task, we can intentionally create an error, to show how a Spring Cloud Task handles errors. To do so:

. Open `src/main/java/io/spring/Timestampapplic.java` in either an IDE or a text editor.
. Insert the following line into the file at line 32:
+
[source,java]
throw new IllegalStateException("No Task For You!");
. From the command line, run `mvn clean spring-boot:run -DskipTests`.
+
NOTE: We must add `-DSkipTests`, because the tests would catch the Exception we added and prevent us from seeing it.
+
Now we can see the Exception we added coming through in the output, as an Exception with a stack trace.  Task has now captured this exception and recorded it to the database. This can be seen in the console as shown here:
+
[source]
----
Updating: TaskExecution with executionId=1 with the following {exitCode=1, endTime=Wed Jul 25 12:42:15 EDT 2018, exitMessage='null', errorMessage='java.lang.IllegalStateException: Failed to execute CommandLineRunner
...
----
+
. Remove or comment out the Exception that we throw on line 32 (so that the next lessons work correctly).

[[task-dev-guide-building-timestamp-task-adding-pre-post-processing]]
=== Adding Pre- and Post-processing

Spring Cloud Task includes the ability to run additional processing both before and after the task. To add both features to our current sample application:

. Open `src/main/java/io/spring/TasklabApplication.java` in either an IDE or a text editor.
. Insert the following code below line 35:
+
[source,java]
----
@BeforeTask
public void beforeTask(TaskExecution taskExecution) {
  System. out.println("Before TASK");
}

@AfterTask
public void afterTask(TaskExecution taskExecution) {
  System. out.println("After TASK");
}
----
. From the command line, run `mvn clean spring-boot:run`.
+
Now the output includes lines that print both `BEFORE TASK` and `AFTER TASK`.

[[task-dev-guide-building-timestamp-task-bonus-adding-mysql]]
=== Bonus Step: Adding a MySQL Database

Nearly always, a real-world Spring Cloud Task needs to use a persistent (rather than an in-memory) database.
In this example, we show how to add a MySQL database (MariaDB) to our Task.
To do so:

. Open the `pom.xml` file.
. Add the following dependency:
+
[source,xml]
----
<dependency>
  <groupId>org.mariadb.jdbc</groupId>
  <artifactId>mariadb-java-client</artifactId>
</dependency>
----
. From your command line set up the database connection properties for MySql for example
+
[source]
----
export spring_datasource_url=jdbc:mariadb://localhost:3306/practice
export spring_datasource_username=root
export spring_datasource_password=password
export spring_datasource_driverClassName=org.mariadb.jdbc.Driver
----
. From the command line, run `mvn clean spring-boot:run`.
+
If you examine the contents of your database, you should now see the task in the `TASK_EXECUTION` table.

[[task-dev-guide-building-timestamp-adding-tasks-to-dataflow]]
== Adding and Launching Spring Cloud Tasks with Data Flow

This guide walks through registering and launching a Spring Cloud Task application.
It consists of the following procedures:

. <<task-dev-guide-building-batch-task-creating-first-task>>
. <<task-dev-guide-building-batch-task-creating-first-batch-task>>

[[task-dev-guide-building-batch-task-creating-first-task]]
=== Registering and Launching Your First Task

Once you have Spring Cloud Data Flow Server and Shell running, you can use the following procedure to create your first task:

. Register a basic suite of tasks by importing their registrations through the Spring Cloud Data Flow Shell with the following command:
+
`app register --name timestamp --type task --uri maven://org.springframework.cloud.task.app:timestamp-task:1.3.0.RELEASE`
+
NOTE: This example shows how to register a task from a Maven repository.
. Verify that the timestamp-task app registered by running the following command in the Spring Cloud Data Flow Shell:
+
`app list`
+
The following output should appear:
+
image:images/dataflow-shell-app-list.png[]
. Create a task definition that uses timestamp task by using the following command in the Spring Cloud Data Flow Shell:
+
`task create --name myStamp --definition "timestamp"`
+
You should see a message saying "Created new task 'myStamp'".
. Launch your new task by using the following command:
+
`task launch myStamp`
+
You should see a message saying "Launched task `myStamp`".
. Verify that your task was successfully run by running the following command in the Spring Cloud Data Flow Shell:
`task execution list`
+
You should see output similar to the following:
+
image:images/dataflow-task-execution-list-timestamp.png[]
+
The exit code of 0 tells us that the task ran without errors.

[[task-dev-guide-building-batch-task-creating-first-batch-task]]
=== Registering and Launching Your First Batch-Task

Essentially, a Batch-Task is a Spring Batch application that includes the `@EnableTask` annotation, which serves as an indicator that the Spring Batch application uses Spring Cloud Task.
Spring Boot takes care of the rest of the set up for us.

To register your first batch task:

. In Spring Cloud Data Flow Shell, register a Spring Batch-Task application by using the following command:
+
`app register --name batch-events --type task --uri maven://org.springframework.cloud.task.app:timestamp-batch-task:2.0.0.RELEASE`
+
. To verify that your application has been registered, run the following command in the Spring Cloud Data Flow Shell:
+
`app list`
+
You should see output similar to the following:
+
image:images/dataflow-app-list-batch-event.png[]
+
. Create a task definition that uses the batch-events task, by running the following command:
+
`task create --name myBatchTask --definition "batch-events"`
+
You should see a message saying "Created new task 'myBatchTask'".
. Launch your batch-task by running the following command:
+
`task launch myBatchTask`
+
You should see a message saying "Launched task `myBatchTask`".
. Verify that the task ran, run the following command:
+
`task execution list`
+
You should see output similar to the following:
+
image:images/dataflow-task-execution-list-batch-events.png[]
+
We can now verify that the task worked as a batch job. The <<task-dev-guide-building-batch-task-verify-batch-task,next section>> describes how to do so.

[[task-dev-guide-building-batch-task-verify-batch-task]]
==== Verifying that Your Task is a Batch

When you create and run a Batch-Task, it is both a Spring Cloud Task instance and a Spring Batch instance.
In the <<task-dev-guide-building-batch-task-creating-first-batch-task,previous section>>, we saw how to verify that your first batch-task worked as a task.
This section steps through how to verify that it also worked as a batch.
To do so:

. Run the following command to see the list of jobs that have run:
+
`job execution list`
+
You should see output similar to the following:
+
image:images/dataflow-job-execution-list.png[]
. Note the Job ID from the ID column (in this case, we want to look at `2`).
. To get the details of the job execution, we can use the Job ID in the following command:
+
`job execution display --id 1`
+
You should see output similar to the following:
+
image:images/dataflow-job-execution-details.png[]

[[task-dev-guide-database-requirement]]
== Database Requirement for running tasks in Spring Cloud Data Flow
As previously discussed Spring Cloud Task records the state of each task execution to a relational database.
And as such Spring Cloud Data Flow uses this recorded information when users request task or batch job execution information.
Also Spring Batch and Spring Cloud Task offer features that allow Spring Cloud Data Flow to communicate certain start or stop behaviors.
One example is when a user utilizes the Spring Cloud Data Flow UI to stop a Spring Batch app execution.
